//闭包的使用场景：当我们想从函数外部访问函数内部的变量的时候往往是失败的。

// 执行上下文（执行环境）主要分为：全局环境、函数环境、Eval环境（少用）
// function a(){
//     b();
//     function b(){
//         c();
//         function c() {
//             console.log("我在里面");
//         }
//     }
// }
// ​
// a();

/*以上代码：
1、当浏览器初次运行代码的时候会创建全局执行上下文（stack = [全局]）全局当中定义了一个函数a并且需要执行
2、创建属于a的函数执行上下文，执行函数b
3、同理到c ：stack = [全局，a,b,c] 然后从尾部
依次输出执行。

*/
// function books(){
//     var book = 'book'
// }

// console.log(book);//这里book为undefined是因为压根没有将books推入执行栈中，所以没有执行过程，自然就不会将book输出

//作用域链： 执行上下文分两个阶段：创建阶段、执行阶段

/*
创建阶段：1、作用域链（当前变量对象＋所有父级变量对象）
         2、变量对象（参数、变量、函数声明）
         3、this
执行阶段：1、变量赋值
         2、函数引用等
*/ 

// function books(){
//     let book = 'book'
//     return function(){
//         console.log(book)
//     }
// }
// let bag = books();
// bag();

/*
以上代码的创建流程：
1、创建全局执行上下文：stack = [全局执行上下文] || 变量对象： books（本身）、bag（引用了books）
2、bag（）创建books执行上下文：stack = [全局，books上下文] || 变量对象: book
3、return 匿名函数创建匿名函数上下文： stack = [全局变量对象，books变量对象, 匿名函数变量对象] || 变量对象: 无
   最顶层的变量对象其优先级是优先的，且包含所有的变量对象，所以可以取到任意一层的变量对象。
4、需要输出book变量：当前执行环境不存在变量，于是到上一个作用域中取得这个变量对象，
*/

// 经典闭包面试题
for (var i = 0; i < 5; i++){
    setTimeout (function (){
        console.log(i++);
    }, 4000);//执行栈执行完所有任务后再等4秒再执行settimeout
}
console.log(i); //这样子是输出5
/*
来龙去脉
1、全局执行上下文：用了settimeout方法，使用了任务队列这个机制，当执行栈执行完毕后再执行任务队列当中的任务。所以全局后i = 5
2、执行任务队列当中的任务，所以最后会出现5,6,7,8,9加上一开始的i= 5 ，最后输出 5,5,6,7,8,9
3、如果想要输出0,1,2，3,4怎么办？运用立即执行函数。
4、因为匿名函数作用域链记录的是全局的变量对象（上面提到当匿名函数不包含需要的变量时，会随着作用域链到上一层去寻找，即全局作用域）
5、将每一轮i的值保存起来
*/

for (var i = 0; i < 5; i++){
    (function(x){
        setTimeout (function (){
            console.log(x++);
        }, 4000);
    })(i)//x引用每次循环时i的值
    
}
console.log(i); 

/*
来龙去脉：
1、全局执行上下文：stack = [全局] || 变量对象只有i
2、到了匿名函数 ：stack = [全局，匿名]  || 变量对象为 x =  当时的i 为 0 
3、然后遇到了settimeout放到任务队列当中去，然后匿名函数执行完毕后再for循环进行下一轮，然后不断有settimeout放到队列当中
4、最后到了全局执行上下文都执行完毕后，将任务队列当中的settimout根据实际时间执行，最后输出 5， 0,1,2,3,4


**要理解闭包，就要理解作用域链
*/

/*
更复杂的：代入内存机制、活动空间、垃圾回收机制
*/
